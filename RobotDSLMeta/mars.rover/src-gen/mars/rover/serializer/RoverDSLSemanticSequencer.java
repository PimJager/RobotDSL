/*
 * generated by Xtext
 */
package mars.rover.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import mars.rover.roverDSL.AssignExpression;
import mars.rover.roverDSL.BBLiteral;
import mars.rover.roverDSL.BNotExpr;
import mars.rover.roverDSL.BSensorLiteral;
import mars.rover.roverDSL.BVBracket;
import mars.rover.roverDSL.BVLiteral;
import mars.rover.roverDSL.BVarLiteral;
import mars.rover.roverDSL.BehaviorName;
import mars.rover.roverDSL.ExpressionBinComp;
import mars.rover.roverDSL.ExpressionBinOp;
import mars.rover.roverDSL.ForwardAction;
import mars.rover.roverDSL.Global;
import mars.rover.roverDSL.IFExpression;
import mars.rover.roverDSL.Implementation;
import mars.rover.roverDSL.MeasureAction;
import mars.rover.roverDSL.Motor;
import mars.rover.roverDSL.Robot;
import mars.rover.roverDSL.RotateAction;
import mars.rover.roverDSL.RoverDSLPackage;
import mars.rover.roverDSL.SAccelerationAction;
import mars.rover.roverDSL.SSpeedAction;
import mars.rover.roverDSL.Static;
import mars.rover.roverDSL.StopAction;
import mars.rover.roverDSL.SubRoutine;
import mars.rover.roverDSL.SubRoutineAction;
import mars.rover.roverDSL.ValExpr;
import mars.rover.roverDSL.WHILEExpression;
import mars.rover.services.RoverDSLGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RoverDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RoverDSLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == RoverDSLPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case RoverDSLPackage.ASSIGN_EXPRESSION:
				sequence_AssignExpression(context, (AssignExpression) semanticObject); 
				return; 
			case RoverDSLPackage.BB_LITERAL:
				sequence_BBLiteral(context, (BBLiteral) semanticObject); 
				return; 
			case RoverDSLPackage.BNOT_EXPR:
				sequence_BNotExpr(context, (BNotExpr) semanticObject); 
				return; 
			case RoverDSLPackage.BSENSOR_LITERAL:
				sequence_BSensorLiteral(context, (BSensorLiteral) semanticObject); 
				return; 
			case RoverDSLPackage.BV_BRACKET:
				sequence_BVBracket(context, (BVBracket) semanticObject); 
				return; 
			case RoverDSLPackage.BV_LITERAL:
				sequence_BVLiteral(context, (BVLiteral) semanticObject); 
				return; 
			case RoverDSLPackage.BVAR_LITERAL:
				sequence_BVarLiteral(context, (BVarLiteral) semanticObject); 
				return; 
			case RoverDSLPackage.BEHAVIOR_NAME:
				sequence_BehaviorName(context, (BehaviorName) semanticObject); 
				return; 
			case RoverDSLPackage.EXPRESSION_BIN_COMP:
				sequence_Blevel3(context, (ExpressionBinComp) semanticObject); 
				return; 
			case RoverDSLPackage.EXPRESSION_BIN_OP:
				sequence_Blevel1(context, (ExpressionBinOp) semanticObject); 
				return; 
			case RoverDSLPackage.FORWARD_ACTION:
				sequence_ForwardAction(context, (ForwardAction) semanticObject); 
				return; 
			case RoverDSLPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case RoverDSLPackage.IF_EXPRESSION:
				sequence_IFExpression(context, (IFExpression) semanticObject); 
				return; 
			case RoverDSLPackage.IMPLEMENTATION:
				sequence_Implementation(context, (Implementation) semanticObject); 
				return; 
			case RoverDSLPackage.MEASURE_ACTION:
				sequence_MeasureAction(context, (MeasureAction) semanticObject); 
				return; 
			case RoverDSLPackage.MOTOR:
				sequence_Motor(context, (Motor) semanticObject); 
				return; 
			case RoverDSLPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case RoverDSLPackage.ROTATE_ACTION:
				sequence_RotateAction(context, (RotateAction) semanticObject); 
				return; 
			case RoverDSLPackage.SACCELERATION_ACTION:
				sequence_SAccelerationAction(context, (SAccelerationAction) semanticObject); 
				return; 
			case RoverDSLPackage.SSPEED_ACTION:
				sequence_SSpeedAction(context, (SSpeedAction) semanticObject); 
				return; 
			case RoverDSLPackage.STATIC:
				sequence_Static(context, (Static) semanticObject); 
				return; 
			case RoverDSLPackage.STOP_ACTION:
				sequence_StopAction(context, (StopAction) semanticObject); 
				return; 
			case RoverDSLPackage.SUB_ROUTINE:
				sequence_SubRoutine(context, (SubRoutine) semanticObject); 
				return; 
			case RoverDSLPackage.SUB_ROUTINE_ACTION:
				sequence_SubRoutineAction(context, (SubRoutineAction) semanticObject); 
				return; 
			case RoverDSLPackage.VAL_EXPR:
				sequence_ValExpr(context, (ValExpr) semanticObject); 
				return; 
			case RoverDSLPackage.WHILE_EXPRESSION:
				sequence_WHILEExpression(context, (WHILEExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (global=[Global|ID] v=ValueExpression)
	 */
	protected void sequence_AssignExpression(EObject context, AssignExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.ASSIGN_EXPRESSION__GLOBAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.ASSIGN_EXPRESSION__GLOBAL));
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.ASSIGN_EXPRESSION__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.ASSIGN_EXPRESSION__V));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignExpressionAccess().getGlobalGlobalIDTerminalRuleCall_0_0_1(), semanticObject.getGlobal());
		feeder.accept(grammarAccess.getAssignExpressionAccess().getVValueExpressionParserRuleCall_2_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     bValue=BOOL_LITERAL
	 */
	protected void sequence_BBLiteral(EObject context, BBLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.BB_LITERAL__BVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.BB_LITERAL__BVALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBBLiteralAccess().getBValueBOOL_LITERALTerminalRuleCall_0(), semanticObject.isBValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     sub=Blevel3
	 */
	protected void sequence_BNotExpr(EObject context, BNotExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.BNOT_EXPR__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.BNOT_EXPR__SUB));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBNotExprAccess().getSubBlevel3ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     sensor=Sensor
	 */
	protected void sequence_BSensorLiteral(EObject context, BSensorLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.BSENSOR_LITERAL__SENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.BSENSOR_LITERAL__SENSOR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSensorLiteralAccess().getSensorSensorEnumRuleCall_0(), semanticObject.getSensor());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     bsub=ValueExpression
	 */
	protected void sequence_BVBracket(EObject context, BVBracket semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.BV_BRACKET__BSUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.BV_BRACKET__BSUB));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBVBracketAccess().getBsubValueExpressionParserRuleCall_1_0(), semanticObject.getBsub());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (neg?='neg'? aValue=INT fraction=INT?)
	 */
	protected void sequence_BVLiteral(EObject context, BVLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_BVarLiteral(EObject context, BVarLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.BVAR_LITERAL__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.BVAR_LITERAL__VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBVarLiteralAccess().getVarIDTerminalRuleCall_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_BehaviorName(EObject context, BehaviorName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.BEHAVIOR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.BEHAVIOR_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBehaviorNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Blevel1_ExpressionBinOp_1_0 bop=BBinaryOp right=Blevel2)
	 */
	protected void sequence_Blevel1(EObject context, ExpressionBinOp semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_OP__LEFT));
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_OP__BOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_OP__BOP));
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_OP__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBlevel1Access().getExpressionBinOpLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBlevel1Access().getBopBBinaryOpEnumRuleCall_1_1_0(), semanticObject.getBop());
		feeder.accept(grammarAccess.getBlevel1Access().getRightBlevel2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Blevel3_ExpressionBinComp_1_0 bcomp=CompareOp right=Blevel4)
	 */
	protected void sequence_Blevel3(EObject context, ExpressionBinComp semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_COMP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_COMP__LEFT));
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_COMP__BCOMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_COMP__BCOMP));
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_COMP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.EXPRESSION_BIN_COMP__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBlevel3Access().getExpressionBinCompLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBlevel3Access().getBcompCompareOpEnumRuleCall_1_1_0(), semanticObject.getBcomp());
		feeder.accept(grammarAccess.getBlevel3Access().getRightBlevel4ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (motor=Motor?)
	 */
	protected void sequence_ForwardAction(EObject context, ForwardAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Global(EObject context, Global semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.GLOBAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.GLOBAL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGlobalAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (c=ValueExpression t+=Expression+ e+=Expression*)
	 */
	protected void sequence_IFExpression(EObject context, IFExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (for=[BehaviorName|ID] controlCheck=ValueExpression expressions+=Expression+)
	 */
	protected void sequence_Implementation(EObject context, Implementation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {MeasureAction}
	 */
	protected void sequence_MeasureAction(EObject context, MeasureAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     m=EMotor
	 */
	protected void sequence_Motor(EObject context, Motor semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.MOTOR__M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.MOTOR__M));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMotorAccess().getMEMotorEnumRuleCall_0(), semanticObject.getM());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         behaviorOrder+=BehaviorName+ 
	 *         globals+=Global* 
	 *         statics+=Static* 
	 *         stopBehaviour=ValueExpression 
	 *         behaviors+=Implementation+ 
	 *         subRoutines+=SubRoutine*
	 *     )
	 */
	protected void sequence_Robot(EObject context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (motor=Motor degrees=ValueExpression blocking?='wait'?)
	 */
	protected void sequence_RotateAction(EObject context, RotateAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (motor=Motor? v=ValueExpression)
	 */
	protected void sequence_SAccelerationAction(EObject context, SAccelerationAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (motor=Motor? v=ValueExpression)
	 */
	protected void sequence_SSpeedAction(EObject context, SSpeedAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=ValueExpression)
	 */
	protected void sequence_Static(EObject context, Static semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.STATIC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.STATIC__NAME));
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.STATIC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.STATIC__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStaticAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStaticAccess().getValueValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (motor=Motor?)
	 */
	protected void sequence_StopAction(EObject context, StopAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     routine=[SubRoutine|ID]
	 */
	protected void sequence_SubRoutineAction(EObject context, SubRoutineAction semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.SUB_ROUTINE_ACTION__ROUTINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.SUB_ROUTINE_ACTION__ROUTINE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSubRoutineActionAccess().getRoutineSubRoutineIDTerminalRuleCall_1_0_1(), semanticObject.getRoutine());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID expressions+=Expression+)
	 */
	protected void sequence_SubRoutine(EObject context, SubRoutine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     vExpr=ValueExpression
	 */
	protected void sequence_ValExpr(EObject context, ValExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RoverDSLPackage.Literals.VAL_EXPR__VEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoverDSLPackage.Literals.VAL_EXPR__VEXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValExprAccess().getVExprValueExpressionParserRuleCall_0(), semanticObject.getVExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (c=ValueExpression b+=Expression+)
	 */
	protected void sequence_WHILEExpression(EObject context, WHILEExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
